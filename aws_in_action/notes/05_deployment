-----------------------------------------------------------------------------
| CHAPTER 5 - AUTOMATING DEPLOYMENT                                         |
-----------------------------------------------------------------------------

- Deploying Applications in a Cloud Environment

    - We'll look at 3 examples that don't require storage solutions in this chapter:

        1. Deploying a VPN solution with AWS CloudFormation and a script that starts at the end of
             the boot process.

        2. Deploying a collaborative text editor with AWS Elastic Beanstalk, which support Node.js by
             default.

        3. Deploying an IRC web client and IRC server with AWS Ops Works.


    - Automated deployment has replaced system admins maunally following installation scripts.  This
        increases efficiency and decreases human error.



- Comparing Deployment Tools

    - The 3 ways to deploy an application which we will look at:

        1. Create a VM and run a deployment script on startup with CloudFormation

        2. Use Elastic Beanstalk to deploy a common web application

        3. Use Ops Works to deploy a multilayer application


    - The effort required to deploy an application using Elastic Beanstalk is low.  However, to benefit 
        from this, you application must fit into the conventions of Elastic Beanstalk.  For instance,
        the app must run on a supported runtime (PHP, Node, .NET, Java, Python, Ruby, Go, Docker).


    - With Ops Works, you have more options.  For instance, you can deploy different layers on top of
        each other.  You can also use a Chef recipe for customization.



- Creating a VM and Running a Deployment Script on Startup with CloudFormation

    - To go from a plain OS to a fully installed and configured VM, use these steps:

        1. Start a plain VM with just the OS

        2. Execute a script at the end of the boot process

        3. Install and configure applications with the help of that script


    - We'll use 'user data' to run the script on startup.  You can inject a small amount of user data
        (< 16 KB) into every VM to customize them.  You specify this during VM creation, then can
        query it later from the machine itself.


    - Whenever you boot a VM from a supported AMI (Amazon Linux, Ubuntu AMI, etc), user data is executed
        as a shell script at the end of the boot process.


    - The user data is always accessible from the VM with a GET request to 
        '169.254.169.254/latest/user-data'.  It is only accessible from the VM itself.



- Deploying OpenSwan (A VPN Server) to a VM

    - Let's say you're working over public WiFi, and you want to tunnel your traffic through a VPN
        because unencrypted communication (ie HTTP instead of HTTPS) can be intercepted by an attacker.

      Our VPN solution, OpenSwan, offers an IPSec-based tunnel that is easy to use.


    - We'll deploy the VPN to a VM with the help of user data and a shell script.  This code is located 
        in 'templates/openstack'.

        1. We have a shell script, 'vpn-setup.sh', which configures OpenStack and the security settings
             on our VM.


        2. We have a CloudFormation template, 'vpn-cloudformation.yaml', which defines how our EC2
             instance will be created.  The VM creation step includes user data to download the 
             'vpn-setup.sh' script from GitHub, then run it.


        3. We have a shell script we run from our machine, 'vpn-create-cloudformation-stack.sh', which
             adds the options for the CloudFormation template, then passes them in and creates the 
             CloudFormation stack, and returns the outputs of the creation.


    - The new template uses the '!Sub' and '!Base64' functions.

        - The '!Sub' function substitutes placeholders $() with their real value.

            !Sub 'Your VPC ID: $(VPC)'      # becomes 'Your VPC ID: vpc-123456'
    

        - The '!Base64' function encodes input with Base64.

            !Base64 'value'                 # becomes 'dmFsdWU='


    - Now, we can terminate the the VM and clean up the environment:

        $ aws cloudformation delete-stack --stack-name vpn


    - If we need to update our script later, the easiest way to do it is to spin up a new VM.

        1. Create a new VM with the new version of the script

        2. Test that it works, or make changes until it does

        3. Once it's up and running, switch the DNS record to point to the new VM, and terminate the old 
            one.



- Deploying a Simple Web Application with AWS Elastic Beanstalk

    - AWS Elastic Beanstalk offers a simple way to deploy a common web application on one of the supported
        runtimes.


    - It lets you handle these common concerns:

         - Providing a runtime environment (ie PHP, Java, etc.)
         - Update the runtime environment
         - Install and update a web application automatically
         - Configure a web application and it's environment
         - Scale a web application to balance load
         - Monitor and debug a web application



- Components of AWS Elastic Beanstalk

    - An 'application' is a logical container.  It contains versions, environments, and configurations.
        Once we create an application, we can use Beanstalk in a specific region.


    - A 'version' contains a specific release of your application.  To create a new version, we upload
        executables (packed into an archive) to to S3.  A version is basically a pointer to this
        archive of executables.


    - A 'configuration template' contains your default configuration.  You can manage your application's
        configuration (ie the port it listens on) with this custom template.


    - An 'environment' is where Beanstalk executes your application.  It consists of a 'version' and a
        'configuration'.



- Using AWS Elastic Beanstalk to Deploy 'EtherPad', Node.js Application

    - Etherpad is an open source online editor that lets many people edit the same document in 
        real time.  It is a Node application.


    - To deploy it with Beanstalk we will:

        1. Create an application, the logical container.

            $ aws elasticbeanstalk create-application --application-name etherpad


        2. Create a version of the application using the zip file we uploaded to S3.

            $ aws elasticbeanstalk create-application-version --application-name etherpad \
                --version-label 1 \
                --source-bundle "S3Bucket=awsinaction-code2,S3Key=chapter05/etherpad.zip"


        3. Create an environment to execute Etherpad

           First, we get the latest Node.js environment version, called a 'solution stack name'.

             $ aws elasticbeanstalk list-available-solution-stacks --output text \
                 --query "SolutionStacks[?contains(@, 'running Node.js')] | [0]"


           Now, we lanuch an environment, replacing '$SolutionStackName' with the output from the
             previous command.

             $ aws elasticbeanstalk create-environment --environment-name etherpad \
                 --application-name etherpad \
                 --option-settings Namespace=aws:elasticbeanstalk:environment, \
                 OptionName=EnvironmentType,Value=SingleInstance \
                 --solution-stack-name "$SolutionStackName" \
                 --version-label 1


    - Now, we can describe our Etherpad environment:

        $ aws elasticbeanstalk describe-environments --environment-names etherpad


    - And we can navigate to the Etherpad application in our web browser using the Public IP Address
        returned in the previous command.


    - We can monitor our application in the AWS console by navigating to 'Services > Elastic Beanstalk'.


    - To clean up:

        # Terminate the Etherpad environment
        $ aws elasticbeanstalk terminate-environment --environment-name etherpad

        # Check the status of the environment
        $ aws elasticbeanstalk describe-environments --environment-names etherpad \
            --output text --query "Environments[].Status"

        # Once the environment status is changed to 'Terminated', delete the application
        $ aws elasticbeanstalk delete-application --application-name etherpad



- Deploying a Multilayer Application with AWS OpsWorks Stacks

    - Elastic Beanstalk is convenient, but if we need to deploy a more complex application consisting
        of different services (layers), you'll need something like OpsWorks.  


    - OpsWorks comes in 2 flavors:

        1. 'AWS OpsWorks Stacks' allows you to deploy applications based on Chef recipes.

        2. 'AWS OpsWorks for Chef Automate' provides a 'Chef Automate' server, which takes care
             of backups, restorations, and software upgrades.


    - Standard layers:

        - HAProxy (load balancer)
        - Static web server
        - Rails app server (Ruby on Rails)
        - PHP app server
        - Node.js app server
        - Java app server (Tomcat server)
        - AWS Flow (Ruby)
        - MySQL (database)
        - Memcached (in-memory cache)
        - Ganglia (monitoring)



- Chef

    - Chef is a configuration management tool similary to Puppet or Ansible.  Chef lets you configure and
        deploy applications by transforming templates (recipes) written in a domain-specific language (DSL) 
        into actions.


    - To get a variety of open sorce recipes, 
        https://supermarket.chef.io


    - Chef can be run in solo or client-server mode.  The client-server mode can be used to manage a
        distributed system consisting of many VMs.  In solo mode, it is used to execute recipes on a
        single VM.



- Components of OpsWorks Stacks

    - A 'stack' is a container for all other components of OpsWorks stacks.  You can create one or more
        stacks, and add one or more layers to each stack.  For example, you could create separate
        stacks for testing and production environments.


    - A 'layer' belongs to a stack.  A layer represents an application, you could also call it a service.
        Either predefined layers (ie Rails app server) can be used, or you can also define custom
        stacks.

      Layers are responsible for configuring and deploying software to virtual machines. You can add one 
        or multiple VMs to a layer; in this context the VMs are called 'instances'.


    - An 'instance' is the representation for a VM.  You can launch one or more instances using 
        standard AMIs like Amazon Linux or Ubuntu.


    - An 'app' is the software you want to deploy.  OpsWorks Stacks deploys your app to a suitable
        layer automatically.



        Stack
        ---------------------------------------------------
        Web server layer:        Instance     Instance
        PHP web application        + App        + App

        API server layer:        Instance     Instance
        Java application           + App        + App

        Database layer:                Instance
        MySQL database                   + DB



- Deploying an IRC Chat Application with AWS OpsWorks Stacks

    - Here, we'll deploy kiwiIRC, a web-based IRC client, and our own IRC server.  kiwiIRC is a Node-based 
        open source application.


    - To create an OpsWorks Stack:

        > Services: OpsWorks Stack
          > Select 'Chef 11'
          > Name: irc
          > Region: US East (N. Virginia)
          > Default VPC
          > Default subnet
          > Default OS: Ubuntu 14.04
          > SSH Key: mykey
          > 'Add Stack'


    - Add a Node.js Layer:

        > Select 'Layers' in menu
          > Add Layer
            > Layer type: Node.js App Server
            > Node version: 0.12.x
            > 'Add Layer'


    - Add a custome layer for the IRC Server:

        > Add Layer
          > Layer type: Custom
          > Name: irc-server
          > 'Add Layer'


    - The IRC server needs to be reachable through port 6667.  To allow access to this port, we need to
        define a custom firewall.  To do this, we'll use a script with CloudFormation commands.  The
        script uses the 'irc-create-cloudformation.yaml' template.

        $ templates/irc/irc-create-cloudformation-stack.sh


    - Next, we need attach this custom firewall configuration to the Custom OpsWorks layer.

        > Layers
          > irc-server Layer
            > Security > Edit
              > Security Groups: Add the 'irc' group


    - Finally, we need to configure the layer recipes for deploying an IRC server:

        > Layers
          > irc-server Layer
            > Recipes > Edit
              > OS Packages: Add 'ircd-ircu' package


    - Now, we can deploy the client app to the Node.js layer we created:

        > Apps
          > Add app
            > Name: kiwiIRC
            > Type: Node.js
            > Repository: https://github.com/AWSinAction/KiwiIRC.git
            > 'Add app'


    - To add instances of the server and client to run the application:

        > Instances
          > Add instance on Node.js App Server layer
            > Size: t2.micro
            > 'Add instance'

        > Instances
          > Add instance on Custom layer
            > Size: t2.micro
            > 'Add instance'



- Using kiwiIRC

    - Write down public IP address of IRC server.  Then, open the client's public IP address in a web
        browser.


    - At the client login screen:

        Nickname: me
        Channel: awsinaction
        Server: server-public-ip
        Port: 6667
        SSL: Disabled

        > Start



- Cleaning Up

    - To clean up:

        - Delete irc-server and irc-client instances
        - Delete the kiwiIRC app
        - Delete the stack

        - Delete the security group
           $ aws cloudformation delete-stack --stack-name irc