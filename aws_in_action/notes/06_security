-----------------------------------------------------------------------------
| CHAPTER 6 - SECURING THE SYSTEM: IAM, SECURITY GROUPS, & VPC              |
-----------------------------------------------------------------------------

- 4 Most Important Security Techniques

    1. Installing software updates

    2. Restricting access to your AWS account

    3. Controlling network traffic to and from EC2 instances

    4. Creating a private network


    - Note that application-level security is not covered in this book.  Follow security standards when
        buying or developing applications.  For example, validate user input, don't save passwords in
        plain text, and use TLS/SSL to encrypt traffic between VMs and users.  Use automated security
        scanning tools like 'Amazon Inspector'.



- Who's Responsible for Security?

    - The cloud is a shared-responsibility environment.  AWS is responsible for:

        - Protecting the network against things like DDoS attacks

        - Performing background checks on employees who have access to sensitive areas

        - Decommissioning storage devices by physically destroying them

        - Ensuring physical and environmental security of data centers


    - Our responsibilities are:

        - Implementing access management that restricts access to resources like S3 and EC2 using AWS IAM

        - Encrypting network traffic to prevent attackers from reading or manipulating data

        - Configuring a firewall for your virtual network that controls incoming and outgoing traffic
            with Security Groups and ACLs

        - Managing patches for the OS and additional software on VMs



- Keeping Software Up to Date

    - If a security update is released, it must be installed quickly, because the exploit may have already
        been released.  We should have a working plan to apply updates to all running VMs as quickly as
        possible.


    - When we log into an Amazon Linux EC2 instance via SSH, we'll see a message about security updates:
        
        $ ssh ec2-user@ec2-34-230-84-110.compute-1.amazonaws.com

        8 package(s) needed for security, out of 8 available
        Run "sudo yum update" to apply all updates.


    - To install updates on systems with yum:

        $ yum --security check-update


    - We should follow feeds for whichever systems we are using to keep up with security issues found,
        and keep track of whether we are affected by them.



- Installing Security Updates on Startup

    - If we create EC2 instances with CloudFormation templates, we have 3 options for installing security
        updates on startup:

        1. Install all updates at the end of the boot process using a user-data script (yum -y update).

        2. Install security updates only at the end of the boot process using a user-data script
             (yum -y --security update).

        3. Define the package versions explicitly.


    - The problem with automatically installing all updates is that you have a different machine than the
        one you tested on.  To test specific package updates, we can use the 'yum update-to' command.

        # Update bash to version 4.2.46-28.37.amzn1
        $ yum update-to bash-4.2.46-28.37.amzn1



- Installing Security Updates on Running VMs

    - If we have a security update we need to apply to lots of running VMs, it's inconvenient to SSH into
        each one.  We have a script, 'update.sh' to do this automatically.


    - Using SSH to install updates, even with the help of a script, can be challenging.  For instance,
        you have to handle all the errors that may occur.  The 'AWS Systems Manager' can make this
        easier, by installing an agent on each machine and creating a job to patch all your VMs.  It
        can also reboot systems if that is required for the updates.



- Securing Your AWS Account

    - All AWS resources are created within an account, a secure basket.  Each AWS account comes with a
        root user that is granted unrestricted access to all resources.  So far, we have been using
        the root user to complete all tasks.


    - A best practice is to avoid using the root user for anything, but we'll add MFA to the account
        in case we do need to use it.

        > Click Your Name
          > My Security Credentials
            > Install a MFA app on your smartphone that supports the TOTP standard (ie Google Authenticator)
            > Expand the MFA section
              > 'Activate MFA'
              > Select a Virtual MFA device
              > Follow the instructions and scan the QR code with your smartphone


    - If you're using your phone for MFA, it's a good idea to never log into the Management Console from
        your phone or store the root password in it.  Keep the MFA token separate from your password.



- AWS IAM

    - IAM Core Concepts

        - An 'IAM User' is used to authenticate people accessing your AWS account.

        - An 'IAM Group' is a collection of IAM Users.

        - An 'IAM Role' is used to authenticate AWS resources.

        - An 'IAM Policy' is used to define the permissions for a user, group, or role.


    - By default, users and roles can't do anything.  You have to create a policy stating what actions
        they are allowed to perform.



- Defining Permissions with an IAM Policy

    - By attaching one or more policies to an IAM user or role, you are granting them permissions to
        manage AWS resources.  Policies are defined in JSON and contain one or more statements.


    - A statement can allow or deny specific actions on specific resources.  The wildcard * can be used
        to create more generic statements.


    - For example, this policy has one statment, which allows every action for the EC2 service, for all
        resources:

        {
          "Version": "2012-10-17",
          "Statement": [{
            "Sid": "1",
            "Effect": "Allow",
            "Action": "ec2:*",
            "Resource": "*"
          }]
        }


    - This policy adds a second statement, which disallows terminating VM instances:

        {
          "Version": "2012-10-17",
          "Statement": [{
            "Sid": "1",
            "Effect": "Allow",
            "Action": "ec2:*",
            "Resource": "*"
          }, {
            "Sid": "2",
            "Effect": "Deny",
            "Action": "ec2:TerminateInstances",
            "Resource": "*"
          }]
        }


    - Note that 'Deny' always overrides 'Allow'.  Once you deny an action, you cannot allow it in
        another statement.


    - So far, we've used '*' for every resource.  Resources in AWS have an 'ARN (Amazon Resource Name)'.

        ARN

        arn:aws:ec2:us-east-1:878533158213:instance/i-3dd4f812
                 |      |          |           |         |
             Service  Region   AccountId    Resource   Resource
                                              Type
                                          (if multiple)


    - We can use the CLI to find out the account id.

        $ aws iam get-user --query "User.Arn" --output text


    - Using the resource and account ids, we can use ARNs to allow access to specific resources of a
        service:

        {
          "Version": "2012-10-17",
          "Statement": [{
            "Sid": "2",
            "Effect": "Allow",
            "Action": "ec2:TerminateInstances",
            "Resource": "arn:aws:ec2:us-east-1:111111111111:instance/i-0b5c991e026104db9"
          }]
        }



- Types of Policies

    - There are 2 types of policies:

        1. Managed Policy = If you want to create policies that can be reused, you will use this.  There
                              are 2 types:

            - AWS Managed Policy = maintained by AWS, grants rights on AWS resources, etc.

            - Customer Managed Policy = maintained by customer, represents users and their roles in the
                                          organization, etc.


        2. Inline Policy = Belongs to a certain IAM role, user, or group.  It can't exist without the
                             role, user, or group it belongs to.


    - With CloudFormation, it's easy to maintain inline policies, which is why they are mostly used in
        this book.  One exception is the 'mycli' user, which has the AWS managed policy
        'AdministratorAccess' attached.



- Users for Authentication, and Groups to Organize Users

    - A user can authenticate using either a username and password, or with access keys.  When you log
        into the Management Console, you use your username and password.  When you use the CLI, you
        are using access keys to authenticate as the 'mycli' user.


    - Right now, we're using the root user to log into the Management Console.  We should create an IAM
        user instead, for 2 reasons:

        1. Creating IAM users allows you to set up a unique user for every person who needs to access
             your AWS account.

        2. You can grant access only to the resources each user needs, following the principle of least
             privilege.


    - To make adding users easier in the future, we'll first create a group for all users with 
        Administrator access.  To create a group:

        # Create group
        $ aws iam create-group --group-name "admin"

        # Attach policy to group
        $ aws iam attach-group-policy --group-name "admin" \
            --policy-arn "arn:aws:iam::aws:policy/AdministratorAccess"

        # Create user and add to group
        $ aws iam create-user --user-name "myuser"
        $ aws iam add-user-to-group --group-name "admin" --user-name "myuser"

        # Replace $Password with a secure pw
        $ aws iam create-login-profile --user-name "myuser" --password "$Password"


    - Now, we can use our new user 'myuser' to access the Management Console.  However, we need to use a
        different URL to access the Console if we aren't using the root user.

        # Use the account id we got earlier in place of $accountId
        https://$accountId.signin.aws.amazon.com/console


    - Note that we should always log in using this account from now on.  Stop using the 'root' user.


    - Also note that we should never copy a user's access keys to an EC2 instance.  We should use IAM
        roles instead.  Don't store security credentials in source code, just use IAM roles!



- Enabling MFA For IAM Users

    - It's a very good idea to enable MFA for all users.  If possible, don't use the same MFA device for
        the root user that you use for everyday users.  You can buy hardware MFA devices for $13 from AWS
        partners like Gemalto.


    - To enable MFA for your users, follow these steps:

        > Services: IAM
          > Users
            > Select User
              > Security Credentials
                > 'Enable MFA'



- Authenticating AWS Resources with Roles

    - There are various use cases where an EC2 instance needs to access or manage AWS resources.  For
        example, an EC2 instance might need to:

        - Back up data to S3

        - Terminate itself after a job has been completed

        - Change the configuration of the private network environment in the cloud


    - To be able to access the AWS API, an EC2 instance needs to authenticate itself.  You could create
        an IAM user with access keys and store the access keys on the EC2 instance, but this is a
        hassle.

      Instead, we should use an IAM role, which will inject your access keys into the EC2 instance
        automatically.


    - If an IAM role is attached to an EC2 instance, all policies attached to those roles are evaluated
        to determine whether the request is allowed.  By default, no role is attached, and the EC2
        instance is not allowed to make any calls to the AWS API.



- Example - EC2 Instance That Auto-Terminates

    - Here, we create an EC2 instance that automatically terminates itself after 5 minutes.

        $ echo "aws ec2 stop-instances --instance-ids i-0b5c991e026104db9" | at now + 5 minutes


    - We need to attach an IAM role to the EC2 instance granting it permission to stop itself.  The
        role contrains an inline policy granting access to the 'ec2:StopInstances' action.  To do this,
        we follow these steps (template at 'templates/06_ec2_role/ec2-iamrole.yaml'):

        1. Create an IAM Role

        2. Create an instance profile

        3. Attach the IAM role to the VM



- Controlling Network Traffic To and From Your VM

    - With a firewall, you can control both inbound (aka 'ingress') and outbound (aka 'egress') traffic.
        For instance, if you run a web server, only ports 80 and 443 need to be open to the outside
        world.


    - Before network traffic can enter or leave your EC2 instance, it goes through a firewall provided
        by AWS.  The firewall inspects the network traffic and uses rules to decide whether the 
        traffic is allowed or denied.


    - Inbound rules filter traffic based on it's source.  Outbound rules filter traffic based on it's
        destination.  The source/destination is either an IP address or a Security Group.

      By default, a security does not allow any inbound traffic.  A security group contains a rule
        allowing all outbound traffic by default.


    - To debug connection problems, you can enable 'VPC Flow Logs', which will give you aggregated
        log messages that will describe why connections were rejected.



- Controlling Traffic to VMs with Security Groups

    - You can associate one or more security groups with AWS Resources (ie EC2 instances) to control
        traffic.  A 'Security Group' consists of a set of rules.  Each rule allows network traffic
        based on the following:

        1. Direction (inbound or outbound)
        
        2. IP Protocol (TCP, UDP, ICMP)

        3. Port

        4. Source or destination based on IP address, IP address range, or security group


    - Security group resources in CloudFormation are of type 'AWS::EC2::SecurityGroup'.  In 
        'templates/06_firewalls/firewall1.yaml', we have an empty security group associated with a
        single EC2 instance.

        firewall1.yaml
        -----------------------------
        Resources:
          SecurityGroup:
            Type: 'AWS::EC2::SecurityGroup'
            Properties:
              GroupDescription: 'Learn how to protect your EC2 Instance.'
              VpcId: !Ref VPC
              Tags:
              - Key: Name
                Value: 'AWS in Action: chapter 6 (firewall)'
        Instance:
          Type: 'AWS::EC2::Instance'
          Properties:
            ...
            NetworkInterfaces:
              GroupSet:
              - !Ref SecurityGroup



- Allowing ICMP Traffic

    - If we want to ping an EC2 instance, we must allow inbound ICMP traffic.  If we try to ping our
        new instance now, it will not work.

        $ ping ec2-52-5-109-147.compute-1.amazonaws.com


    - We'll update our template ('firewall2.yaml') to allow it:

        SecurityGroup:
          ...
          SecurityGroupIngress:         # Allows incoming traffic
          - IpProtocol: icmp            # ICMP protocol
            FromPort: '-1'              # All ports (ICMP doesn't use ports)
            ToPort: '-1'                # All ports
            CidrIp: '0.0.0.0/0'         # All source IP addresses allowed


    - Now we can ping our instance, and it should work.



- Allowing SSH Traffic

    - To allow SSH access to our VM, we add another rule ('firewall3.yaml'):

        SecurityGroup:
          ...
          SecurityGroupIngress:         # Allows incoming traffic
          - IpProtocol: tcp
            FromPort: '22'
            ToPort: '22'
            CidrIp: '0.0.0.0/0'


    - Once we update our template, SSH should now work also.



- Allowing SSH Traffic From a Source IP Address

    - Public vs Private IP Addresses

        - On our local network, we use private IP addresses, and each of our devices has a separate one.

            Class A Private:    10.0.0.0    - 10.255.255.255
            Class B Private:    172.16.0.0  - 172.31.255.255
            Class C Private:    192.168.0.0 - 192.168.255.255

        - Only our gateway (the router) has a public IP address, and all requests are redirected to the
            gateway (via NAT).  Our local devices only know that the internet gateway is reachable via
            192.168.0.1 on the private network.

        - To get your public IP address, visit http://api.ipify.org .  For most of us, our public IP
            changes from time to time, usually when you reconnect to the internet.


    - So far, we've been allowing traffic to port 22 from all IP addresses.  It is possible to restrict
        access to only your own IP address for additional security as well.


    - Hard-coding the IP address isn't a great idea since it changes from time to time.  So, we need to
        add a parameter to the template that holds our current IP address.  We'll update this with
        'firewall4.yaml'.

        - IpProtocol: tcp
          FromPort: '22'
          ToPort: '22'
          CidrIp: !Sub '${IpForSSH}/32'


    - We'll type in our current IP address, and now SSH will only be available from our IP.



- Allowing SSH Traffic From a Source Security Group

    - It is possible to control network traffic based on whether the source or destination belongs to
        a specific security group (this applies to other AWS resouces only, obviously).  For example,
        you can say that a MySQL database can only be accessed from your web servers.


    - To explore this concept, we'll create a 'bastion host' (aka a 'jump box') for SSH access.  The
        trick is that only one VM, the bastion host, can be accessed via SSH from the internet.  All
        other VMs can only be reached via SSH from the bastion host.

      Advantages of this:

        1. You only have one entry point into your system, and that entry point does nothing but SSH.

        2. If one of your VMs gets hacked, the attacker can't jump from that one machine to all the
             other machines.


    - To implement the concept of a bastion host, you must follow 2 rules:

        1. Allow SSH access to the bastion host from 0.0.0.0 or a specific source address.

        2. Allow SSH access to all other VMs only if the traffic source is the bastion host.


    - We'll update our stack ('firewall5.yaml') with these security groups:

        SecurityGroupBastionHost:
          Type: 'AWS::EC2::SecurityGroup'
          Properties:
            GroupDescription: 'Allowing incoming SSH and ICPM from anywhere.'
            VpcId: !Ref VPC
            SecurityGroupIngress:
            - IpProtocol: icmp
              FromPort: "-1"
              ToPort: "-1"
              CidrIp: '0.0.0.0/0'
            - IpProtocol: tcp
              FromPort: '22'
              ToPort: '22'
              CidrIp: !Sub '${IpForSSH}/32'
        SecurityGroupInstance:
          Type: 'AWS::EC2::SecurityGroup'
          Properties:
            GroupDescription: 'Allowing incoming SSH from the Bastion Host.'
            VpcId: !Ref VPC
            SecurityGroupIngress:
            - IpProtocol: tcp
              FromPort: '22'
              ToPort: '22'
              SourceSecurityGroupId: !Ref SecurityGroupBastionHost


    - Our new template has 3 outputs:

        1. BastionHostPublicName = Use this bastion host to connect via SSH from your computer.

        2. Instance1PublicName = Connect to this host only from the bastion host.

        3. Instance2PublicName = Connect to this host only from the bastion host.


    - To connect to one of the instances from our machine:

        # Add the path to our SSH key to our SSH agent
        $ ssh-add $PathToKey/mykey.pem

        # Connect to the bastion host (-A option allows agent forwarding)
        $ ssh -A ec2-user@$BastionHostPublicName

        # Now we can log into an instance from the bastion host
        $ ssh $Instance1PublicName


    - Note that using Agent Forwarding is a potential security risk, since the bastion host is able
        to read the private key from your computer.  Therefore, you need to fully trust the bastion
        host when using agent forwarding.

      A more secure alternative is using the bastion host as a proxy.

        # Establish an SSH connection to Instance1 by using the bastion host as a proxy
        $ ssh -J ec2-user@BastionHostPublicName ec2-user@Instance1PublicName